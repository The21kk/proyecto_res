<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapa Interactivo del Museo</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        #map {
            height: 90vh;
            width: 100%;
        }
        #controls {
            margin: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="controls">
        <label for="comunaSelect">Filtrar por Comuna:</label>
        <select id="comunaSelect" onchange="filterByComuna()">
            <option value="">Todas</option>
        </select>

        <label for="startPoint">Punto de Inicio:</label>
        <select id="startPoint"></select>

        <label for="endPoint">Punto Final:</label>
        <select id="endPoint"></select>

        <!-- Campo para ingresar dirección alternativa si no se permite geolocalización -->
        <input type="text" id="manualAddress" placeholder="Dirección de inicio alternativa" style="display: none;">

        <!-- Filtros de metadata adicionales -->
        <fieldset>
            <legend>Filtros de Metadata</legend>
            
            <!-- Tipo de Institución -->
            <label for="tipoInstSelect">Tipo de Institución:</label>
            <select id="tipoInstSelect" onchange="filterByMetadata()">
                <option value="">Todos</option>
                <option value="Museo">Museo</option>
                <option value="Centro Cultural">Centro Cultural</option>
            </select>

            <!-- Filtros de Atributos Booleanos -->
            <label><input type="checkbox" id="arteFilter" onchange="filterByMetadata()"> Arte</label>
            <label><input type="checkbox" id="historiaFilter" onchange="filterByMetadata()"> Historia</label>
            <label><input type="checkbox" id="cobroFilter" onchange="filterByMetadata()"> Entrada Gratuita</label>
        </fieldset>

        <button onclick="calculateRoute()">Calcular Ruta</button>
    </div>
    <div id="map"></div>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-pip@1.1.0/leaflet-pip.min.js"></script>
    <script>
        const map = L.map('map').setView([-33.4489, -70.6693], 13); // Santiago de Chile
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

        let startMarker, endMarker;
        let comunaLayer; // Capa para todas las comunas
        const startSelect = document.getElementById('startPoint');
        const endSelect = document.getElementById('endPoint');
        const points = {}; // Almacena los puntos de cada capa por nombre
        const pointLayers = []; // Almacena las capas de puntos de interés para manipularlas

        // Función para agregar los puntos a los selectores
        function addPointToSelector(name, latlng) {
            points[name] = latlng;
            const optionStart = new Option(name, name);
            const optionEnd = new Option(name, name);
            startSelect.add(optionStart);
            endSelect.add(optionEnd);
        }

        // Cargar capa de comunas y agregar al selector de filtro
        fetch('/comunas')
            .then(response => response.json())
            .then(data => {
                comunaLayer = L.geoJSON(data, {
                    style: { color: 'blue', weight: 1, fillOpacity: 0.1 },
                    onEachFeature: function (feature, layer) {
                        if (feature.properties && feature.properties.Comuna) {
                            const comunaName = feature.properties.Comuna;
                            layer.bindPopup(comunaName);

                            // Agregar opción de comuna al selector
                            const option = new Option(comunaName, comunaName);
                            document.getElementById('comunaSelect').add(option);
                        }
                    }
                }).addTo(map);
            })
            .catch(error => console.error('Error al cargar el GeoJSON de comunas:', error));

        // Función para filtrar puntos por comuna seleccionada
        function filterByComuna() {
            const selectedComuna = document.getElementById('comunaSelect').value;

            // Eliminar los puntos de interés actuales del mapa
            pointLayers.forEach(layer => map.removeLayer(layer));
            pointLayers.length = 0;  // Limpiar la lista de capas de puntos

            // Si no hay una comuna seleccionada, cargar todos los puntos de ambas capas
            if (!selectedComuna) {
                loadPoints('/capa1', 'blue', 'start');  // Museos
                loadPoints('/capa2', 'red', 'end');     // Monumentos
                return;
            }

            // Encontrar la capa de la comuna seleccionada y crear un GeoJSON compatible
            const selectedFeature = comunaLayer.getLayers().find(layer => 
                layer.feature.properties.Comuna === selectedComuna
            );

            if (selectedFeature) {
                const selectedLayer = L.geoJSON(selectedFeature.toGeoJSON());
                loadPoints('/capa1', 'blue', 'start', selectedLayer);
                loadPoints('/capa2', 'red', 'end', selectedLayer);
            }
        }

        // Cargar puntos desde una capa y ajustar para soportar MultiPoint
        function loadPoints(url, color, type, selectedLayer = null) {
            fetch(url)
                .then(response => response.json())
                .then(data => {
                    const layer = L.geoJSON(data, {
                        pointToLayer: function (feature, latlng) {
                            // Aplicar filtros de metadata
                            if (!passesMetadataFilters(feature.properties)) return null;

                            // Si la geometría es MultiPoint, extraer el primer punto
                            const geometry = feature.geometry;
                            if (geometry.type === "MultiPoint" && geometry.coordinates.length > 0) {
                                const [lng, lat] = geometry.coordinates[0];
                                latlng = L.latLng(lat, lng);
                            }

                            // Si hay una comuna seleccionada, verificar si el punto está dentro
                            if (selectedLayer) {
                                const isWithin = leafletPip.pointInLayer([latlng.lng, latlng.lat], selectedLayer);
                                if (isWithin.length === 0) return null;
                            }

                            // Agregar punto de interés y marcar en el selector
                            if (feature.properties && feature.properties.nombre) {
                                addPointToSelector(feature.properties.nombre, latlng);
                            }
                            return L.circleMarker(latlng, {
                                radius: 8,
                                color: color,
                                fillColor: color,
                                fillOpacity: 0.5
                            }).on('click', () => selectPoint(feature.properties.nombre, type));
                        }
                    }).addTo(map);

                    // Agregar capa de puntos a la lista de capas
                    pointLayers.push(layer);
                })
                .catch(error => console.error(`Error al cargar puntos de ${url}:`, error));
        }

        // Cargar todos los puntos al inicio
        loadPoints('/capa1', 'blue', 'start'); // Museos
        loadPoints('/capa2', 'red', 'end'); // Monumentos

        // Función para capturar la geolocalización o habilitar el campo manual
        function captureUserLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    position => {
                        const userLat = position.coords.latitude;
                        const userLng = position.coords.longitude;
                        const userLocation = L.latLng(userLat, userLng);

                        // Agrega la ubicación del usuario al selector de inicio
                        addPointToSelector("Ubicación Actual", userLocation);
                        map.setView(userLocation, 13);

                        startSelect.value = "Ubicación Actual";
                    },
                    () => {
                        document.getElementById("manualAddress").style.display = "block";
                    }
                );
            } else {
                document.getElementById("manualAddress").style.display = "block";
            }
        }

        // Llama a la función de captura al cargar la página
        window.onload = captureUserLocation;

        // Función para verificar si un museo cumple con los filtros de metadata
        function passesMetadataFilters(properties) {
            const tipoInst = document.getElementById("tipoInstSelect").value;
            const arteFilter = document.getElementById("arteFilter").checked;
            const historiaFilter = document.getElementById("historiaFilter").checked;
            const cobroFilter = document.getElementById("cobroFilter").checked;

            if (tipoInst && properties.tipo_inst !== tipoInst) return false;
            if (arteFilter && properties.arte !== "Sí") return false;
            if (historiaFilter && properties.historia !== "Sí") return false;
            if (cobroFilter && properties.cobro_ent !== "Ingreso gratuito") return false;

            return true;
        }

        // Función para aplicar filtros de metadata
        function filterByMetadata() {
            pointLayers.forEach(layer => map.removeLayer(layer));
            pointLayers.length = 0;

            loadPoints('/capa1', 'blue', 'start');
            loadPoints('/capa2', 'red', 'end');
        }

        // Función para calcular la ruta
        function calculateRoute() {
            const startName = startSelect.value;
            const endName = endSelect.value;
            const manualAddress = document.getElementById("manualAddress").value;

            if (manualAddress && !startName) {
                geocodeAddress(manualAddress, coords => {
                    addPointToSelector("Inicio Manual", coords);
                    startSelect.value = "Inicio Manual";
                    calculateRoute();
                });
                return;
            }

            if (startName && endName && points[startName] && points[endName]) {
                const start = points[startName];
                const end = points[endName];

                if (startMarker) startMarker.remove();
                if (endMarker) endMarker.remove();
                startMarker = L.marker(start).addTo(map).bindPopup(`Inicio: ${startName}`).openPopup();
                endMarker = L.marker(end).addTo(map).bindPopup(`Fin: ${endName}`).openPopup();

                fetch(`https://router.project-osrm.org/route/v1/driving/${start.lng},${start.lat};${end.lng},${end.lat}?overview=full&geometries=geojson`)
                    .then(response => response.json())
                    .then(data => {
                        const route = data.routes[0].geometry;
                        if (window.routeLayer) map.removeLayer(window.routeLayer);
                        window.routeLayer = L.geoJSON(route, {
                            style: { color: 'green', weight: 4, opacity: 0.7 }
                        }).addTo(map);
                    })
                    .catch(error => console.error('Error al obtener la ruta:', error));
            } else {
                alert('Por favor, selecciona puntos de inicio y fin válidos.');
            }
        }

        // Función de geocodificación para convertir la dirección en coordenadas
        function geocodeAddress(address, callback) {
            fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${address}`)
                .then(response => response.json())
                .then(data => {
                    if (data && data.length > 0) {
                        const lat = data[0].lat;
                        const lng = data[0].lon;
                        callback(L.latLng(lat, lng));
                    } else {
                        alert("Dirección no encontrada");
                    }
                })
                .catch(error => console.error('Error al geocodificar la dirección:', error));
        }
    </script>
</body>
</html>
